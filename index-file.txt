import {
  createServerBuilder,
  SimpleLogger,
  StdioTransport,
  ServerBuilder
} from '@modelcontextprotocol/typescript-sdk';
import { config, initFacebookSdk, validateConfig } from './config';
import * as campaignTools from './tools/campaign-tools';
import * as audienceTools from './tools/audience-tools';
import * as analyticsTools from './tools/analytics-tools';
import { prompts, fillPromptTemplate } from './prompts/campaign-templates';

// Vytvo≈ôen√≠ loggeru
const logger = new SimpleLogger('facebook-ads-mcp-server');

// Funkce pro inicializaci serveru
const initializeServer = async (): Promise<ServerBuilder> => {
  // Kontrola konfigurace
  if (!validateConfig()) {
    throw new Error('Neplatn√° konfigurace. Zkontrolujte .env soubor.');
  }
  
  // Inicializace Facebook SDK
  initFacebookSdk();
  
  // Vytvo≈ôen√≠ serveru
  const builder = createServerBuilder({
    name: 'facebook-ads-mcp-server',
    version: '1.0.0',
    description: 'MCP server pro zad√°v√°n√≠ a vyhodnocov√°n√≠ reklamn√≠ch kampan√≠ na Facebooku pomoc√≠ Claude AI',
    transport: new StdioTransport({ logger }),
    logger
  });
  
  // Registrace n√°stroj≈Ø pro spr√°vu kampan√≠
  builder.tool({
    name: 'create_campaign',
    description: 'Vytvo≈ô√≠ novou reklamn√≠ kampa≈à na Facebooku',
    handler: async ({ name, objective, status, dailyBudget, startTime, endTime }) => {
      const result = await campaignTools.createCampaign(
        name,
        objective,
        status,
        dailyBudget ? parseFloat(dailyBudget as string) : undefined,
        startTime as string,
        endTime as string
      );
      
      return {
        content: [
          {
            type: 'text',
            text: result.success 
              ? `‚úÖ Kampa≈à byla √∫spƒõ≈°nƒõ vytvo≈ôena!\n\nID kampanƒõ: ${result.campaignId}\n\n${result.message}`
              : `‚ùå Chyba p≈ôi vytv√°≈ôen√≠ kampanƒõ: ${result.message}`
          }
        ]
      };
    },
    inputSchema: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'N√°zev kampanƒõ' },
        objective: { type: 'string', description: 'C√≠l kampanƒõ (nap≈ô. REACH, LINK_CLICKS, CONVERSIONS)' },
        status: { type: 'string', description: 'Status kampanƒõ (ACTIVE, PAUSED)' },
        dailyBudget: { type: 'string', description: 'Denn√≠ rozpoƒçet v mƒõnƒõ √∫ƒçtu' },
        startTime: { type: 'string', description: 'ƒåas zaƒç√°tku kampanƒõ ve form√°tu ISO (YYYY-MM-DDTHH:MM:SS+0000)' },
        endTime: { type: 'string', description: 'ƒåas konce kampanƒõ ve form√°tu ISO (YYYY-MM-DDTHH:MM:SS+0000)' }
      },
      required: ['name', 'objective', 'status']
    }
  });
  
  builder.tool({
    name: 'get_campaigns',
    description: 'Z√≠sk√° seznam reklamn√≠ch kampan√≠',
    handler: async ({ limit, status }) => {
      const result = await campaignTools.getCampaigns(
        limit ? parseInt(limit as string) : undefined,
        status as string
      );
      
      if (!result.success) {
        return {
          content: [
            {
              type: 'text',
              text: `‚ùå Chyba p≈ôi z√≠sk√°v√°n√≠ kampan√≠: ${result.message}`
            }
          ]
        };
      }
      
      // P≈ô√≠prava form√°tovan√©ho textu s kampanƒõmi
      let responseText = `üìã Seznam reklamn√≠ch kampan√≠ (celkem ${result.campaigns.length}):\n\n`;
      
      if (result.campaigns.length === 0) {
        responseText += 'Nebyly nalezeny ≈æ√°dn√© kampanƒõ odpov√≠daj√≠c√≠ zadan√Ωm krit√©ri√≠m.';
      } else {
        result.campaigns.forEach((campaign, index) => {
          responseText += `${index + 1}. **${campaign.name}** (ID: ${campaign.id})\n`;
          responseText += `   - C√≠l: ${campaign.objective}\n`;
          responseText += `   - Status: ${campaign.status}\n`;
          responseText += `   - Denn√≠ rozpoƒçet: ${campaign.dailyBudget ? `${campaign.dailyBudget}` : 'Nen√≠ nastaven'}\n`;
          responseText += `   - Vytvo≈ôeno: ${new Date(campaign.createdTime).toLocaleDateString()}\n\n`;
        });
      }
      
      return {
        content: [
          {
            type: 'text',
            text: responseText
          }
        ]
      };
    },
    inputSchema: {
      type: 'object',
      properties: {
        limit: { type: 'string', description: 'Maxim√°ln√≠ poƒçet kampan√≠ k zobrazen√≠' },
        status: { type: 'string', description: 'Filtrov√°n√≠ podle statusu (ACTIVE, PAUSED, ARCHIVED)' }
      }
    }
  });
  
  builder.tool({
    name: 'get_campaign_details',
    description: 'Z√≠sk√° detailn√≠ informace o konkr√©tn√≠ kampani',
    handler: async ({ campaignId }) => {
      const result = await campaignTools.getCampaignDetails(campaignId as string);
      
      if (!result.success) {
        return {
          content: [
            {
              type: 'text',
              text: `‚ùå Chyba p≈ôi z√≠sk√°v√°n√≠ detail≈Ø kampanƒõ: ${result.message}`
            }
          ]
        };
      }
      
      const campaign = result.campaign;
      let responseText = `üìä Detaily kampanƒõ "${campaign.name}" (ID: ${campaign.id}):\n\n`;
      
      responseText += `- **Z√°kladn√≠ informace:**\n`;
      responseText += `  - C√≠l: ${campaign.objective}\n`;
      responseText += `  - Status: ${campaign.status}\n`;
      responseText += `  - Typ n√°kupu: ${campaign.buyingType}\n`;
      
      responseText += `\n- **Rozpoƒçet a finance:**\n`;
      if (campaign.dailyBudget) {
        responseText += `  - Denn√≠ rozpoƒçet: ${campaign.dailyBudget}\n`;
      }
      if (campaign.lifetimeBudget) {
        responseText += `  - Celo≈æivotn√≠ rozpoƒçet: ${campaign.lifetimeBudget}\n`;
      }
      if (campaign.spendCap) {
        responseText += `  - Limit v√Ωdaj≈Ø: ${campaign.spendCap}\n`;
      }
      if (campaign.budgetRemaining) {
        responseText += `  - Zb√Ωvaj√≠c√≠ rozpoƒçet: ${campaign.budgetRemaining}\n`;
      }
      
      responseText += `\n- **ƒåasov√© √∫daje:**\n`;
      responseText += `  - Vytvo≈ôeno: ${new Date(campaign.createdTime).toLocaleString()}\n`;
      if (campaign.startTime) {
        responseText += `  - Zaƒç√°tek: ${new Date(campaign.startTime).toLocaleString()}\n`;
      }
      if (campaign.stopTime) {
        responseText += `  - Konec: ${new Date(campaign.stopTime).toLocaleString()}\n`;
      }
      
      if (campaign.specialAdCategories && campaign.specialAdCategories.length > 0) {
        responseText += `\n- **Speci√°ln√≠ kategorie reklam:** ${campaign.specialAdCategories.join(', ')}\n`;
      }
      
      return {
        content: [
          {
            type: 'text',
            text: responseText
          }
        ]
      };
    },
    inputSchema: {
      type: 'object',
      properties: {
        campaignId: { type: 'string', description: 'ID kampanƒõ' }
      },
      required: ['campaignId']
    }
  });
  
  builder.tool({
    name: 'update_campaign',
    description: 'Aktualizuje existuj√≠c√≠ reklamn√≠ kampa≈à',
    handler: async ({ campaignId, name, status, dailyBudget, endTime }) => {
      const result = await campaignTools.updateCampaign(
        campaignId as string,
        name as string,
        status as string,
        dailyBudget ? parseFloat(dailyBudget as string) : undefined,
        endTime as string
      );
      
      return {
        content: [
          {
            type: 'text',
            text: result.success 
              ? `‚úÖ Kampa≈à byla √∫spƒõ≈°nƒõ aktualizov√°na!\n\n${result.message}`
              : `‚ùå Chyba p≈ôi aktualizaci kampanƒõ: ${result.message}`
          }
        ]
      };
    },
    inputSchema: {
      type: 'object',
      properties: {
        campaignId: { type: 'string', description: 'ID kampanƒõ' },
        name: { type: 'string', description: 'Nov√Ω n√°zev kampanƒõ' },
        status: { type: 'string', description: 'Nov√Ω status kampanƒõ (ACTIVE, PAUSED)' },
        dailyBudget: { type: 'string', description: 'Nov√Ω denn√≠ rozpoƒçet v mƒõnƒõ √∫ƒçtu' },
        endTime: { type: 'string', description: 'Nov√Ω ƒças konce kampanƒõ ve form√°tu ISO (YYYY-MM-DDTHH:MM:SS+0000)' }
      },
      required: ['campaignId']
    }
  });
  
  builder.tool({
    name: 'delete_campaign',
    description: 'Odstran√≠ reklamn√≠ kampa≈à',
    handler: async ({ campaignId }) => {
      const result = await campaignTools.deleteCampaign(campaignId as string);
      
      return {
        content: [
          {
            type: 'text',
            text: result.success 
              ? `‚úÖ Kampa≈à byla √∫spƒõ≈°nƒõ odstranƒõna!\n\n${result.message}`
              : `‚ùå Chyba p≈ôi odstra≈àov√°n√≠ kampanƒõ: ${result.message}`
          }
        ]
      };
    },
    inputSchema: {
      type: 'object',
      properties: {
        campaignId: { type: 'string', description: 'ID kampanƒõ' }
      },
      required: ['campaignId']
    }
  });
  
  // Registrace n√°stroj≈Ø pro anal√Ωzu a vyhodnocov√°n√≠
  builder.tool({
    name: 'get_campaign_insights',
    description: 'Z√≠sk√° analytick√° data o v√Ωkonu reklamn√≠ kampanƒõ',
    handler: async ({ campaignId, since, until, metrics }) => {
      const timeRange = {
        since: since as string,
        until: until as string
      };
      
      let metricsArray = ['impressions', 'clicks', 'spend', 'cpc', 'ctr', 'reach', 'frequency'];
      if (metrics) {
        metricsArray = (metrics as string).split(',').map(m => m.trim());
      }
      
      const result = await analyticsTools.getCampaignInsights(
        campaignId as string,
        timeRange,
        metricsArray
      );
      
      if (!result.success) {
        return {
          content: [
            {
              type: 'text',
              text: `‚ùå Chyba p≈ôi z√≠sk√°v√°n√≠ analytick√Ωch dat: ${result.message}`
            }
          ]
        };
      }
      
      if (!result.insights) {
        return {
          content: [
            {
              type: 'text',
              text: `‚ÑπÔ∏è ${result.message}`
            }
          ]
        };
      }
      
      // Form√°tov√°n√≠ v√Ωsledk≈Ø
      let responseText = `üìà Analytick√° data kampanƒõ za obdob√≠ ${since} - ${until}:\n\n`;
      
      // Souhrnn√© statistiky
      let totalImpressions = 0;
      let totalClicks = 0;
      let totalSpend = 0;
      
      result.insights.forEach(insight => {
        totalImpressions += parseInt(insight.impressions || '0');
        totalClicks += parseInt(insight.clicks || '0');
        totalSpend += parseFloat(insight.spend ||